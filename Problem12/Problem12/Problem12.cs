using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Diagnostics;

namespace ProjectEuler 
{
	/// <summary>
	//Highly divisible triangular number
	//Problem 12
	//The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

	//1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

	//Let us list the factors of the first seven triangle numbers:

	// 1: 1
	// 3: 1,3
	// 6: 1,2,3,6
	//10: 1,2,5,10
	//15: 1,3,5,15
	//21: 1,3,7,21
	//28: 1,2,4,7,14,28
	//We can see that 28 is the first triangle number to have over five divisors.

	//What is the value of the first triangle number to have over five hundred divisors?
	/// </summary>
	class Problem12
	{
		private static ulong answer = 0;
		private static List<int>factorCounts = new List<int>();

		private static Dictionary<uint, List<uint>> triangleFactors;

		//performance measurements
		private static int iterations = 0;
		private static List<TimeSpan> iterationTimeSpans = new List<TimeSpan>();
		private static Stopwatch stopwatch = new Stopwatch();

		static void Main(string[] args)
		{
			Stopwatch runtimeStopwatch = Stopwatch.StartNew();

			//initialize the first 7 triangle number factor counts (given to us)
			// 1: 1
			// 3: 1,3
			// 6: 1,2,3,6
			//10: 1,2,5,10
			//15: 1,3,5,15
			//21: 1,3,7,21
			//28: 1,2,4,7,14,28
			Problem12.factorCounts.Add(1);
			Problem12.factorCounts.Add(2);
			Problem12.factorCounts.Add(4);
			Problem12.factorCounts.Add(4);
			Problem12.factorCounts.Add(4);
			Problem12.factorCounts.Add(4);
			Problem12.factorCounts.Add(6);

			ulong triangleNumber = 28;            
			int n = 7;            

			int factorCount = 6;            

			while (factorCount < 501)
			{
				//stopwatch = Stopwatch.StartNew();
				//increment n
				n++;
				Debug.WriteLine("n: " + n.ToString());                

				//generate new triangle number
				triangleNumber = Problem12.CalculateNthTriangleNumber((ulong)n);
				Debug.WriteLine("t: " + triangleNumber);

				factorCount = Problem12.DetermineNumberOfFactors(triangleNumber, FactoringMethod.Basic);
				Debug.WriteLine("factors: " + factorCount.ToString());

				//stopwatch.Stop();
				//iterationTimeSpans.Add(stopwatch.Elapsed);
				Problem12.iterations++;
			}

			Problem12.answer = triangleNumber;

			Console.WriteLine(string.Format("answer: {0}", Problem12.answer.ToString()));
			Console.WriteLine(string.Format("number of divisors: {0}", factorCount.ToString()));
			Console.WriteLine(string.Format("Nth Triangle Number; N= {0}", n.ToString()));

			runtimeStopwatch.Stop();
			//Console.WriteLine("iterations performed: " + Problem12.iterationTimeSpans.Count.ToString());
			Console.WriteLine("iterations performed: " + Problem12.iterations.ToString());
			//Console.WriteLine("average iteration time (ms): " + Problem12.iterationTimeSpans.Average(t => t.TotalMilliseconds).ToString());
			//Console.WriteLine("max iteration time (ms): " + Problem12.iterationTimeSpans.Max(t => t).TotalMilliseconds.ToString());
			Console.WriteLine("Runtime (ms): " + runtimeStopwatch.Elapsed.TotalMilliseconds.ToString());

			Console.ReadLine();
		}

		//http://www.gmathacks.com/quant-topics/number-of-factors-of-a-large-integer.html
		//To generalize that method, here's your approach:
		//1. Find the prime factorization of a number (each one of the number's prime factors raised to the appropriate power).
		//2.ulong List all of the exponents.
		//2.ulong Add one to each of the exponents. (Remember, it's possible to raise the prime factor to the zero power.)
		//2. Multiply the resulting numbers.

		//Find the Number of Factors of 196
		//Let's try those steps with 196. I've never seen a specific GMAT question asking for the number of factors of 196, but it's exactly the sort of number they are likely to use.

		//The prime factorization: 196 = (2^2)(7^2)
		//The powers: 2 and 2
		//Add one to the powers: 3 and 3
		//Multiply the results: (3)(3) = 9
		//There are 9 factors of 196. To see what those are, work through the permutations of the exponents 0, 1, and 2 for the prime factors 2 and 7:
		//(2^0)(7^0) = 1
		//(2^1)(7^0) = 2
		//(2^2)(7^0) = 4
		//(2^0)(7^1) = 7
		//(2^1)(7^1) = 14
		//(2^2)(7^1) = 28
		//(2^0)(7^2) = 49
		//(2^1)(7^2) = 98
		//(2^2)(7^2) = 196
		private static int DetermineNumberOfFactors(ulong numberToFactor, FactoringMethod method = FactoringMethod.Basic)
		{
			int numberOfFactors = 1;

			switch (method)
			{
				case FactoringMethod.Remember:
					{
						throw new System.NotImplementedException("Remember Factor Method Not Implemented");
						//break;
					}
				case FactoringMethod.Long:
					{
						throw new System.NotImplementedException("Long Factor Method Not Implemented");

						IEnumerable<IGrouping<ulong, ulong>> primeFactors = PrimeNumbers.Factorize(numberToFactor).GroupBy(n => n);
						IEnumerator<IGrouping<ulong, ulong>> primeFactorsEnum = primeFactors.GetEnumerator();

						while (primeFactorsEnum.MoveNext())
						{
							numberOfFactors = checked(numberOfFactors * (primeFactorsEnum.Current.Count() + 1));
						}

						break;
					}
				default:
					{
						double sqrt = Math.Sqrt(numberToFactor);
						double quotient;
						//start at 2 for 1 & itself
						numberOfFactors = 2;
						for (int i = 2; i <= sqrt; i++)
						{
							quotient = (double)numberToFactor / (double)i;
							if (quotient % 1 == 0)
							{
								//double braces used in string.format
								//http://stackoverflow.com/questions/3773857/escape-curly-brace-in-string-format
								//Debug.WriteLine(string.Format("{{{0},{1}}}", i.ToString(), quotient.ToString()));
								numberOfFactors += 2;                                
							}
						}                        
						break;
					}
			}			

			return numberOfFactors;
		}

		private static ulong CalculateNthTriangleNumber(ulong n)
		{
			return (n * (n + 1)) / 2;
		}

		private enum FactoringMethod
		{
			Basic
		   ,Remember
		   ,Long
		}
	}
}
